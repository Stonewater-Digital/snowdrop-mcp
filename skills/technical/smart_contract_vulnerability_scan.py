"""
Executive Summary: Analyze DeFi smart contract metadata for reentrancy, delegatecall, centralization, and access control vulnerabilities with risk scoring.
Inputs: contract_data (dict: bytecode_hash, functions, has_reentrancy_guard, uses_delegatecall, owner_functions)
Outputs: vulnerabilities (list), risk_score (float 0-10), recommendations (list), safe_to_interact (bool)
MCP Tool Name: smart_contract_vulnerability_scan
"""
import os
import logging
from typing import Any
from datetime import datetime, timezone

logger = logging.getLogger("snowdrop.skills")

TOOL_META = {
    "name": "smart_contract_vulnerability_scan",
    "description": "Analyze DeFi smart contract metadata for common vulnerability patterns: reentrancy, unchecked delegatecall, centralization risk, and missing access controls. Returns risk score and recommendations.",
    "inputSchema": {
        "type": "object",
        "properties": {
            "contract_data": {
                "type": "object",
                "description": "Contract metadata dict with: bytecode_hash (str, optional), functions (list of {name, visibility, modifiers}), has_reentrancy_guard (bool), uses_delegatecall (bool), owner_functions (list of function names).",
                "properties": {
                    "bytecode_hash": {"type": "string"},
                    "functions": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {"type": "string"},
                                "visibility": {"type": "string"},
                                "modifiers": {"type": "array", "items": {"type": "string"}}
                            }
                        }
                    },
                    "has_reentrancy_guard": {"type": "boolean"},
                    "uses_delegatecall": {"type": "boolean"},
                    "owner_functions": {"type": "array", "items": {"type": "string"}}
                }
            }
        },
        "required": ["contract_data"]
    },
    "outputSchema": {
        "type": "object",
        "properties": {
            "vulnerabilities": {"type": "array"},
            "risk_score": {"type": "number"},
            "recommendations": {"type": "array"},
            "safe_to_interact": {"type": "boolean"},
            "status": {"type": "string"},
            "timestamp": {"type": "string"}
        },
        "required": ["vulnerabilities", "risk_score", "recommendations", "safe_to_interact", "status", "timestamp"]
    }
}

# Severity weight in risk score (0-10 scale)
_SEVERITY_WEIGHTS: dict[str, float] = {
    "critical": 3.5,
    "high": 2.5,
    "medium": 1.5,
    "low": 0.5,
    "info": 0.1,
}

# Dangerous function name patterns that indicate high-risk operations
_DANGEROUS_FUNC_PATTERNS = [
    ("selfdestruct", "critical", "Function can destroy contract and drain all funds."),
    ("suicide", "critical", "Deprecated selfdestruct alias — contract can be destroyed."),
    ("transferOwnership", "medium", "Ownership transfer function present — verify access controls."),
    ("renounceOwnership", "high", "Ownership can be renounced, making contract permanently uncontrolled."),
    ("upgradeTo", "high", "Upgrade function present — proxy upgrade path requires careful governance."),
    ("setImplementation", "high", "Implementation address can be changed — proxy manipulation risk."),
    ("withdraw", "medium", "Direct withdrawal function — verify reentrancy protection."),
    ("mint", "medium", "Token minting function — verify supply control and access."),
    ("burn", "medium", "Token burn function — verify it cannot be called by unauthorized parties."),
    ("pause", "low", "Circuit breaker pause function — centralized but generally acceptable."),
    ("unpause", "low", "Unpause function — verify governance controls."),
]

# Visibility risk levels
_VISIBILITY_RISK: dict[str, str] = {
    "public": "low",
    "external": "low",
    "internal": "info",
    "private": "info",
}

# Protective modifiers that reduce risk
_PROTECTIVE_MODIFIERS = {
    "onlyOwner", "nonReentrant", "whenNotPaused", "onlyRole",
    "requiresAuth", "onlyAdmin", "onlyGovernance", "onlyDAO",
    "onlyMultisig", "onlyTimelock",
}


def _check_reentrancy(contract_data: dict) -> list[dict]:
    """Check for reentrancy vulnerability patterns.

    Args:
        contract_data: Contract metadata dict.

    Returns:
        List of vulnerability dicts if reentrancy risk found.
    """
    issues = []
    has_guard = contract_data.get("has_reentrancy_guard", False)
    functions = contract_data.get("functions", [])

    # Look for external-value-transfer functions without reentrancy guard
    transfer_func_names = {"withdraw", "transfer", "send", "call", "claim", "redeem"}
    risky_funcs = [
        f for f in functions
        if any(t in f.get("name", "").lower() for t in transfer_func_names)
        and f.get("visibility", "") in ("public", "external")
        and "nonReentrant" not in f.get("modifiers", [])
    ]

    if risky_funcs and not has_guard:
        func_names = [f.get("name", "unknown") for f in risky_funcs]
        issues.append({
            "type": "reentrancy",
            "severity": "critical",
            "description": (
                f"Functions {func_names} make external calls or value transfers without "
                "reentrancy guard. Vulnerable to reentrancy attacks (e.g. DAO hack pattern)."
            ),
            "affected_functions": func_names,
            "cwe": "CWE-841",
            "swc": "SWC-107",
        })
    elif risky_funcs and has_guard:
        issues.append({
            "type": "reentrancy_guard_present",
            "severity": "info",
            "description": "ReentrancyGuard detected — transfer functions are protected.",
            "affected_functions": [],
            "cwe": None,
            "swc": None,
        })

    return issues


def _check_delegatecall(contract_data: dict) -> list[dict]:
    """Check for unchecked delegatecall vulnerability.

    Args:
        contract_data: Contract metadata dict.

    Returns:
        List of vulnerability dicts if delegatecall risk found.
    """
    issues = []
    uses_delegatecall = contract_data.get("uses_delegatecall", False)

    if uses_delegatecall:
        # Check if there are access controls on upgrade/delegation functions
        functions = contract_data.get("functions", [])
        upgrade_funcs = [
            f for f in functions
            if any(kw in f.get("name", "").lower() for kw in ("upgrade", "setimpl", "setlogic", "delegat"))
        ]
        unprotected = [
            f for f in upgrade_funcs
            if not any(m in _PROTECTIVE_MODIFIERS for m in f.get("modifiers", []))
        ]

        severity = "critical" if unprotected else "high"
        issues.append({
            "type": "delegatecall",
            "severity": severity,
            "description": (
                "Contract uses delegatecall. If the implementation address can be changed by "
                "an attacker, all contract state and funds are at risk (proxy hijack)."
                + (" Upgrade functions appear unprotected." if unprotected else " Upgrade functions appear protected.")
            ),
            "affected_functions": [f.get("name", "") for f in unprotected],
            "cwe": "CWE-829",
            "swc": "SWC-112",
        })

    return issues


def _check_centralization(contract_data: dict) -> list[dict]:
    """Check for centralization risk via owner-only functions.

    Args:
        contract_data: Contract metadata dict.

    Returns:
        List of vulnerability dicts based on owner function count and severity.
    """
    issues = []
    owner_functions = contract_data.get("owner_functions", [])
    total_functions = len(contract_data.get("functions", []))

    if not owner_functions:
        return issues

    centralization_ratio = len(owner_functions) / max(total_functions, 1)

    # Classify severity by the number and ratio of owner-only functions
    if len(owner_functions) >= 5 or centralization_ratio > 0.4:
        severity = "high"
        desc = (
            f"{len(owner_functions)} functions are owner-only ({centralization_ratio:.0%} of total). "
            "High centralization risk — a compromised owner key can drain funds or rug-pull users."
        )
    elif len(owner_functions) >= 2:
        severity = "medium"
        desc = (
            f"{len(owner_functions)} functions are owner-only. "
            "Verify owner is a multisig or DAO, not an EOA."
        )
    else:
        severity = "low"
        desc = f"1 owner-only function ({owner_functions[0]}). Low centralization risk if owner is a multisig."

    issues.append({
        "type": "centralization_risk",
        "severity": severity,
        "description": desc,
        "affected_functions": list(owner_functions),
        "owner_function_count": len(owner_functions),
        "total_function_count": total_functions,
        "centralization_ratio": round(centralization_ratio, 4),
        "cwe": "CWE-285",
        "swc": "SWC-105",
    })

    return issues


def _check_access_controls(contract_data: dict) -> list[dict]:
    """Check for functions missing access control modifiers.

    Args:
        contract_data: Contract metadata dict.

    Returns:
        List of vulnerability dicts for unprotected state-changing functions.
    """
    issues = []
    functions = contract_data.get("functions", [])

    # State-changing functions that should have access controls
    sensitive_keywords = {"set", "update", "change", "admin", "config", "param", "fee", "rate", "owner"}
    unprotected = []

    for f in functions:
        fname = f.get("name", "").lower()
        visibility = f.get("visibility", "").lower()
        modifiers = {m.lower() for m in f.get("modifiers", [])}
        has_protection = bool(modifiers & {m.lower() for m in _PROTECTIVE_MODIFIERS})

        if (
            visibility in ("public", "external")
            and any(kw in fname for kw in sensitive_keywords)
            and not has_protection
        ):
            unprotected.append(f.get("name", "unknown"))

    if unprotected:
        issues.append({
            "type": "missing_access_control",
            "severity": "high",
            "description": (
                f"Functions {unprotected} appear to be state-changing with sensitive names "
                "but lack recognized access control modifiers (onlyOwner, onlyRole, etc.)."
            ),
            "affected_functions": unprotected,
            "cwe": "CWE-284",
            "swc": "SWC-105",
        })

    return issues


def _check_dangerous_functions(contract_data: dict) -> list[dict]:
    """Scan function names against known dangerous pattern list.

    Args:
        contract_data: Contract metadata dict.

    Returns:
        List of vulnerability dicts for matched dangerous function patterns.
    """
    issues = []
    functions = contract_data.get("functions", [])
    func_names_lower = {f.get("name", "").lower(): f.get("name", "") for f in functions}

    for pattern, severity, description in _DANGEROUS_FUNC_PATTERNS:
        matched = [orig for low, orig in func_names_lower.items() if pattern.lower() in low]
        if matched:
            issues.append({
                "type": f"dangerous_function_{pattern.lower()}",
                "severity": severity,
                "description": description,
                "affected_functions": matched,
                "cwe": None,
                "swc": None,
            })

    return issues


def smart_contract_vulnerability_scan(contract_data: dict) -> dict:
    """Analyze DeFi smart contract metadata for security vulnerabilities.

    Runs five independent vulnerability checks: reentrancy, delegatecall,
    centralization, access controls, and dangerous function patterns. Each
    finding is weighted by severity to produce a 0-10 risk score. Scores
    above 7 are considered unsafe to interact with without further audit.

    Args:
        contract_data: Contract metadata dict with:
            - bytecode_hash (str, optional): Contract bytecode hash for reference.
            - functions (list): List of {name, visibility, modifiers} dicts.
            - has_reentrancy_guard (bool): Whether ReentrancyGuard is present.
            - uses_delegatecall (bool): Whether contract uses delegatecall.
            - owner_functions (list): Names of owner-restricted functions.

    Returns:
        A dict with keys:
            - vulnerabilities (list): Found vulnerability dicts with type, severity, description.
            - risk_score (float): Aggregate risk score from 0 (safe) to 10 (critical).
            - recommendations (list): Actionable security recommendations.
            - safe_to_interact (bool): True if risk_score < 7.
            - status (str): "success" or "error".
            - timestamp (str): ISO 8601 UTC timestamp.
    """
    try:
        if not isinstance(contract_data, dict):
            raise TypeError(f"contract_data must be a dict, got {type(contract_data).__name__}.")

        # Run all checks
        vulnerabilities: list[dict] = []
        vulnerabilities.extend(_check_reentrancy(contract_data))
        vulnerabilities.extend(_check_delegatecall(contract_data))
        vulnerabilities.extend(_check_centralization(contract_data))
        vulnerabilities.extend(_check_access_controls(contract_data))
        vulnerabilities.extend(_check_dangerous_functions(contract_data))

        # Filter out info-only items for risk scoring
        scoreable = [v for v in vulnerabilities if v["severity"] != "info"]

        # Compute risk score (sum of severity weights, capped at 10.0)
        raw_score = sum(_SEVERITY_WEIGHTS.get(v["severity"], 0.0) for v in scoreable)
        risk_score = round(min(raw_score, 10.0), 2)

        # Generate recommendations based on findings
        recommendations: list[str] = []
        finding_types = {v["type"] for v in vulnerabilities}

        if "reentrancy" in finding_types:
            recommendations.append(
                "Add OpenZeppelin ReentrancyGuard to all functions that make external calls or transfer ETH/tokens."
            )
        if "delegatecall" in finding_types:
            recommendations.append(
                "Restrict upgrade functions to a multisig timelock with at least 48-hour delay. "
                "Audit the implementation contract's storage layout for slot collisions."
            )
        if "centralization_risk" in finding_types:
            recommendations.append(
                "Transfer contract ownership to a Gnosis Safe multisig (3-of-5 minimum) or a DAO governance contract."
            )
        if "missing_access_control" in finding_types:
            recommendations.append(
                "Apply onlyOwner or role-based access control (OpenZeppelin AccessControl) to all state-changing functions."
            )
        if any("dangerous_function_selfdestruct" in t or "dangerous_function_suicide" in t for t in finding_types):
            recommendations.append(
                "CRITICAL: Remove selfdestruct/suicide functions entirely. These allow permanent contract destruction."
            )
        if not recommendations:
            recommendations.append(
                "No major issues detected in metadata scan. Still recommend a formal code audit before mainnet deployment."
            )

        recommendations.append(
            "Request a third-party audit from a reputable firm (Trail of Bits, OpenZeppelin, Certik) before handling significant TVL."
        )

        safe_to_interact = risk_score < 7.0

        # Severity summary
        severity_counts = {sev: 0 for sev in _SEVERITY_WEIGHTS}
        for v in vulnerabilities:
            sev = v.get("severity", "info")
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        return {
            "status": "success",
            "vulnerabilities": vulnerabilities,
            "risk_score": risk_score,
            "recommendations": recommendations,
            "safe_to_interact": safe_to_interact,
            "severity_summary": severity_counts,
            "total_findings": len(vulnerabilities),
            "bytecode_hash": contract_data.get("bytecode_hash", "not_provided"),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }

    except Exception as e:
        logger.error(f"smart_contract_vulnerability_scan failed: {e}")
        _log_lesson(f"smart_contract_vulnerability_scan: {e}")
        return {
            "status": "error",
            "error": str(e),
            "vulnerabilities": [],
            "risk_score": 10.0,
            "recommendations": ["Analysis failed — treat contract as unsafe until manually reviewed."],
            "safe_to_interact": False,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }


def _log_lesson(message: str) -> None:
    """Append an error lesson to the lessons log file.

    Args:
        message: The lesson message to record.
    """
    try:
        with open("logs/lessons.md", "a") as f:
            f.write(f"- [{datetime.now(timezone.utc).isoformat()}] {message}\n")
    except OSError:
        logger.warning("Could not write to logs/lessons.md")
